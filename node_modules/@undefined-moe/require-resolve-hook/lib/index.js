"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unhook = exports.bypass = void 0;
var Module = require('module');
var isMatch = function (match, id) {
    if (Array.isArray(match)) {
        return match.some(function (mat) { return isMatch(mat, id); });
    }
    var shouldUseHook = false;
    if (typeof match === 'function') {
        shouldUseHook = match(id);
    }
    else if (typeof match === 'string') {
        shouldUseHook = id === match;
    }
    else if (match instanceof RegExp) {
        shouldUseHook = match.test(id);
    }
    return shouldUseHook;
};
var requireResolveHook = function (match, onResolve, options) {
    if (options === void 0) { options = {}; }
    var argv = [match, onResolve, options];
    var hook = function () {
        var argvList = (Module.__require_resolve_hook__ = Module.__require_resolve_hook__ || []);
        argvList.push(argv);
        if (!Module.__require_resolve_hook_origin_resolveFilename__) {
            Module.__require_resolve_hook_origin_resolveFilename__ = Module._resolveFilename;
            var _resolveFilename_1 = Module._resolveFilename;
            Module._resolveFilename = function (request, parent, isMain, options) {
                var argvList = (Module.__require_resolve_hook__ || []).slice();
                while (argvList.length) {
                    var _a = argvList.shift(), match_1 = _a[0], onResolve_1 = _a[1], _b = _a[2], opts = _b === void 0 ? {} : _b;
                    var _c = opts.ignoreModuleNotFoundError, ignoreModuleNotFoundError = _c === void 0 ? true : _c;
                    if (match_1) {
                        if (isMatch(match_1, request)) {
                            try {
                                var result = onResolve_1(request, parent, isMain, options);
                                if (result && typeof result === 'string') {
                                    return result;
                                }
                            }
                            catch (err) {
                                if (ignoreModuleNotFoundError && err && 'MODULE_NOT_FOUND' === err.code) {
                                    return;
                                }
                                throw err;
                            }
                        }
                    }
                }
                return _resolveFilename_1.call(this, request, parent, isMain, options);
            };
        }
    };
    var unhook = function () {
        var argvList = Module.__require_resolve_hook__ || [];
        var index = argvList.indexOf(argv);
        if (index >= 0) {
            argvList.splice(index, 1);
        }
        if (!argvList.length) {
            unhookGlobal();
        }
    };
    hook();
    return {
        bypass: function (fn) {
            unhook();
            var result;
            try {
                result = fn();
            }
            finally {
                hook();
            }
            return result;
        },
        unhook: function () { return unhook(); }
    };
};
var bypass = function (fn) {
    var _resolveFilename = Module._resolveFilename;
    Module._resolveFilename = Module.__require_resolve_hook_origin_resolveFilename__ || Module._resolveFilename;
    var result;
    try {
        result = fn();
    }
    finally {
        Module._resolveFilename = _resolveFilename;
    }
    return result;
};
exports.bypass = bypass;
var unhookGlobal = function () {
    Module._resolveFilename = Module.__require_resolve_hook_origin_resolveFilename__ || Module._resolveFilename;
    delete Module.__require_resolve_hook_origin_resolveFilename__;
    delete Module.__require_resolve_hook__;
};
exports.unhook = unhookGlobal;
exports.default = requireResolveHook;
