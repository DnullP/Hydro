var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var shorty_exports = {};
__export(shorty_exports, {
  Shorty: () => Shorty,
  default: () => shorty_default
});
module.exports = __toCommonJS(shorty_exports);
class Shorty {
  constructor(tokensize = 10) {
    this.tokensize = tokensize;
    this.curpos = 0;
    this.bitCount = 7;
    this.bitChar = 0;
    this.nodes = [];
    this.nyt = 0;
    this.nodecount = 0;
    this.reset(true);
  }
  reset(full = false) {
    if (full === true) {
      this.nodes = [{ up: 0, weight: 0 }];
      this.nyt = 0;
      this.nodecount = 0;
    }
    this.data = "";
    this.curpos = 0;
    this.bitCount = 7;
    this.bitChar = 0;
  }
  findNode(x) {
    for (let i = this.nodes.length - 1; i > 0; i--) {
      if (typeof this.nodes[i].symbol !== "undefined" && this.nodes[i].symbol === x)
        return i;
    }
    return 0;
  }
  addNode(token) {
    if (this.nodecount >= 2046)
      return 0;
    this.nodes[++this.nodecount] = { up: this.nyt, symbol: token, weight: 1 };
    this.nodes[++this.nodecount] = { up: this.nyt, weight: 0 };
    this.nodes[this.nyt].weight += 1;
    this.nyt = this.nodecount;
    if (this.nodes[this.nodecount - 2].up !== this.nodecount - 2)
      this.balanceNode(this.nodes[this.nodecount - 2].up);
    return this.nodecount - 2;
  }
  swapNode(a, b) {
    const t = this.nodes[a].symbol;
    const u = this.nodes[b].symbol;
    const v = this.nodes[a].weight;
    this.nodes[a].symbol = u;
    this.nodes[b].symbol = t;
    this.nodes[a].weight = this.nodes[b].weight;
    this.nodes[b].weight = v;
    for (let n = this.nodes.length - 1; n > 0; n--) {
      if (this.nodes[n].up === a)
        this.nodes[n].up = b;
      else if (this.nodes[n].up === b)
        this.nodes[n].up = a;
    }
  }
  balanceNode(node) {
    while (true) {
      let minnr = node;
      const weight = this.nodes[node].weight;
      while (minnr > 1 && this.nodes[minnr - 1].weight === weight)
        minnr--;
      if (minnr !== node && minnr !== this.nodes[node].up) {
        this.swapNode(minnr, node);
        node = minnr;
      }
      this.nodes[node].weight++;
      if (this.nodes[node].up === node)
        return;
      node = this.nodes[node].up;
    }
  }
  emitNode(node) {
    const emit = [];
    while (node !== 0) {
      emit.unshift(node % 2);
      node = this.nodes[node].up;
    }
    for (let e = 0; e < emit.length; e++)
      this.emitBit(emit[e]);
  }
  emitNyt(token) {
    this.emitNode(this.nyt);
    const ll = token.length - 1;
    if (this.tokensize > 8)
      this.emitBit(ll & 8);
    if (this.tokensize > 4)
      this.emitBit(ll & 4);
    if (this.tokensize > 2)
      this.emitBit(ll & 2);
    if (this.tokensize > 1)
      this.emitBit(ll & 1);
    for (let cc = 0; cc < token.length; cc++) {
      this.emitByte(token.charCodeAt(cc));
    }
    return this.nyt;
  }
  readNode() {
    if (this.nyt === 0) {
      let len = (this.tokensize > 8 ? this.readBit() * 8 : 0) + (this.tokensize > 4 ? this.readBit() * 4 : 0) + (this.tokensize > 2 ? this.readBit() * 2 : 0) + (this.tokensize > 1 ? this.readBit() : 0) + 1;
      const stream = [];
      while (len--)
        stream.push(this.readByte());
      return stream;
    }
    let node = 0;
    while (true) {
      const bit = this.readBit();
      if (this.nodes[node].symbol === void 0) {
        for (let m = 0; ; m++) {
          if (this.nodes[m].up === node && m !== node && m % 2 === bit) {
            node = m;
            break;
          }
        }
      }
      if (this.nodes[node].symbol !== void 0 || this.nodes[node].weight === 0) {
        if (this.nodes[node].weight)
          return this.nodes[node].symbol;
        let len = (this.tokensize > 8 ? this.readBit() * 8 : 0) + (this.tokensize > 4 ? this.readBit() * 4 : 0) + (this.tokensize > 2 ? this.readBit() * 2 : 0) + (this.tokensize > 1 ? this.readBit() : 0) + 1;
        const stream = [];
        while (len--)
          stream.push(this.readByte());
        return stream;
      }
    }
  }
  emitBit(bit) {
    if (bit)
      this.bitChar += 1 << this.bitCount;
    if (--this.bitCount < 0) {
      this.data += String.fromCharCode(this.bitChar);
      this.bitCount = 7;
      this.bitChar = 0;
    }
  }
  emitByte(byte) {
    for (let i = 7; i >= 0; i--)
      this.emitBit(byte >> i & 1);
  }
  readBit() {
    if (this.curpos === this.data.length * 8)
      throw "done";
    const bit = this.data.charCodeAt(this.curpos >> 3) >> (7 - this.curpos & 7) & 1;
    this.curpos++;
    return bit;
  }
  readByte() {
    let res = 0;
    for (let i = 0; i < 8; i++)
      res += (128 >> i) * this.readBit();
    return res;
  }
  deflate(data) {
    let token;
    this.arrayBuffer = new TextEncoder().encode(data);
    const l = this.arrayBuffer.length;
    let i;
    let x;
    this.reset();
    for (i = 0; i < l; i++) {
      token = String.fromCharCode(this.arrayBuffer[i]);
      if (this.tokensize > 1) {
        if (/[a-zA-Z]/.test(token)) {
          while (i + 1 < l && token.length < this.tokensize && /[a-zA-Z]/.test(String.fromCharCode(this.arrayBuffer[i + 1]))) {
            token += String.fromCharCode(this.arrayBuffer[++i]);
          }
        } else if (/[=[\],.:"'{}]/.test(token)) {
          while (i + 1 < l && token.length < this.tokensize && /[=[\],.:"'{}]/.test(String.fromCharCode(this.arrayBuffer[i + 1]))) {
            i++;
            token += String.fromCharCode(this.arrayBuffer[i]);
          }
        }
      }
      x = this.findNode(token);
      if (!x) {
        this.emitNyt(token);
        x = this.addNode(token);
      } else {
        this.emitNode(x);
        this.balanceNode(x);
      }
    }
    if (this.bitCount !== 7) {
      const oldlength = this.arrayBuffer.length;
      this.emitNode(this.nyt);
      if (oldlength === this.arrayBuffer.length)
        this.emitByte(0);
    }
    return this.data;
  }
  inflate(data) {
    this.reset();
    this.data = data;
    const output = [];
    try {
      while (true) {
        const token = this.readNode();
        output.push(...token);
        const node = this.findNode(token);
        if (!node)
          this.addNode(token);
        else
          this.balanceNode(node);
      }
    } catch (e) {
    }
    return new TextDecoder().decode(new Uint8Array(output));
  }
}
var shorty_default = Shorty;
